# Лабораторная работа 4 - Многотабличные запросы к базе данных

## Урок 1: Использование множественных запросов

### Введение

Реляционные базы данных представляют собой мощную платформу для хранения и обработки больших объемов информации. Одной из ключевых особенностей реляционной модели является возможность манипулирования данными различными способами, такими как объединение, пересечение, вычитание и декартово произведение. PostgreSQL, как одна из самых популярных систем управления базами данных (СУБД), предлагает широкий спектр инструментов для выполнения сложных операций над несколькими наборами данных одновременно

Когда речь идет о работе с большими объемами данных, часто требуется объединять результаты различных запросов в единый набор данных. Для этого используются операторы UNION, UNION ALL, INTERSECT и EXCEPT. Кроме того, иногда бывает полезно создавать декартовы произведения, то есть комбинации всех возможных пар записей из двух таблиц. Все эти методы имеют свою специфику и область применения, и знание их особенностей позволяет эффективно решать разнообразные задачи анализа и обработки данных

### Объединение таблиц (UNION и UNION ALL)

Объединение таблиц – это процесс создания единого набора данных из результатов двух или более запросов. PostgreSQL поддерживает два основных способа объединения: с использованием оператора UNION (с автоматическим удалением дубликатов) и оператора UNION ALL (без удаления дубликатов).

**Основные принципы работы операторов UNION и UNION ALL**

Операторы UNION и UNION ALL предназначены для объединения результатов нескольких запросов в один результирующий набор данных. Однако между ними существует важное различие:

_UNION_: Автоматически удаляет дублирующиеся строки из итогового результата. Если в исходных наборах данных встречаются одинаковые строки, они будут представлены только один раз в финальном наборе.

_UNION ALL_: Сохраняет все строки, включая возможные дубликаты. Если строки повторяются в исходных запросах, они появятся столько раз, сколько раз встречаются в каждом из запросов.

Эти операторы особенно полезны, когда необходимо объединить данные из разных таблиц или подмножеств одной таблицы, например, для получения общего списка элементов, которые могут находиться в разных источниках.

Синтаксис:

```sql
SELECT column_list_1 FROM table_1

UNION | UNION ALL

SELECT column_list_2 FROM table_2;
```

При использовании операторов UNION и UNION ALL важно помнить несколько правил:

1. Количество столбцов и их типы должны совпадать в обоих запросах. Например, если первый запрос выбирает три столбца типа INTEGER, VARCHAR и DATE, то и второй запрос должен выбирать три столбца тех же типов.
2. Порядок следования столбцов тоже важен. Первый столбец в первом запросе будет сопоставлен первому столбцу во втором запросе, и так далее
3. Если имена столбцов различаются, результат будет содержать заголовки столбцов из первого запроса

**Пример 1: Использование UNION**

Предположим, у нас есть две таблицы: employees и contractors. Мы хотим получить список всех людей, работающих в компании, включая сотрудников и подрядчиков.

Таблица employees:

| id  | name   |
| --- | ------ |
| 6   | Иван   |
| 2   | Сергей |
| 3   | Ольга  |

Таблица contractors:

| id  | name   |
| --- | ------ |
| 4   | Андрей |
| 5   | Мария  |
| 6   | Иван   |

Запрос:

```sql
SELECT id, name FROM employees

UNION

SELECT id, name FROM contractors;
```

Результат:

| id  | name   |
| --- | ------ |
| 6   | Иван   |
| 2   | Сергей |
| 3   | Ольга  |
| 4   | Андрей |
| 5   | Мария  |

Обратите внимание, что строка с именем "Иван" появляется только один раз, так как оператор UNION удаляет дубликаты.

**Пример 2: Использование UNION ALL**

Теперь предположим, что нам нужно сохранить все записи, даже если они повторяются.

Запрос:

```sql
SELECT id, name FROM employees

UNION ALL

SELECT id, name FROM contractors;

```

Результат:

| id  | name   |
| --- | ------ |
| 6   | Иван   |
| 2   | Сергей |
| 3   | Ольга  |
| 4   | Андрей |
| 5   | Мария  |
| 6   | Иван   |

Здесь строка с именем "Иван" появляется дважды, поскольку оператор UNION ALL не удаляет дубликаты.

### Пересечение таблиц (INTERSECT)

Пересечение таблиц – это операция, которая возвращает строки, присутствующие в обоих исходных наборах данных. Оператор INTERSECT используется для нахождения общих элементов между двумя запросами. Эта операция полезна, когда необходимо определить, какие записи существуют в обоих наборах данных.

**Основные принципы работы оператора INTERSECT**

Оператор _INTERSECT_ работает аналогично математическому пересечению множеств. Он сравнивает два набора данных и возвращает только те строки, которые присутствуют в обоих наборах. Дубликаты автоматически удаляются, так что каждая уникальная строка встречается только один раз в результате.

Важно отметить, что порядок строк в результате пересечения не гарантируется. Также, как и в случае с операторами UNION и UNION ALL, количество и типы столбцов в обоих запросах должны совпадать.

**Синтаксис:**

```sql
SELECT column_list_1 FROM table_1

INTERSECT

SELECT column_list_2 FROM table_2;
```

**Пример:**

Допустим, у нас есть две таблицы: students и athletes.

Таблица students:

| student_id | name    |
| ---------- | ------- |
| 101        | Алексей |
| 102        | Анна    |
| 103        | Борис   |

Таблица athletes:

| athlete_id | name |
| ---------- | ---- |
| 201        | Олег |
| 202        | Алла |
| 203        | Анна |

Мы хотим узнать, кто из студентов является спортсменами.

Запрос:

```sql
SELECT name FROM students

INTERSECT

SELECT name FROM athletes;

```

Результат:

| name |
| ---- |
| Анна |

Таким образом, только Анна присутствует в обеих таблицах.

### Разность таблиц (EXCEPT)

Разность таблиц – это операция, возвращающая строки из первого набора данных, которых нет во втором наборе. Она помогает выявить различия между двумя наборами данных. Оператор EXCEPT применяется для определения строк, существующих в одном наборе, но отсутствующих в другом.

**Основные принципы работы оператора EXCEPT**

Оператор EXCEPT действует подобно математической операции вычитания множеств. Он сравнивает два набора данных и возвращает строки, которые присутствуют в первом наборе, но отсутствуют во втором. Как и в предыдущих случаях, дубликаты автоматически удаляются, и каждая уникальная строка встречается только один раз в результате.

Порядок строк в результате разности не гарантируется. Требования к количеству и типам столбцов в обоих запросах остаются теми же, что и для других операторов множественного запроса.

**Синтаксис:**

```sql
SELECT column_list_1 FROM table_1

EXCEPT

SELECT column_list_2 FROM table_2;

```

**Пример:**

Используем те же таблицы students и athletes, чтобы узнать, какие студенты не являются спортсменами.

Запрос:

```sql
SELECT name FROM students

EXCEPT

SELECT name FROM athletes;

```

Результат:

| name    |
| ------- |
| Алексей |
| Борис   |

Это означает, что Алексей и Борис отсутствуют в таблице спортсменов.

### Декартово произведение таблиц

Декартово произведение – это операция, которая создает новый набор данных путем соединения каждой строки первой таблицы с каждой строкой второй таблицы. Результатом такой операции становится таблица, содержащая все возможные комбинации строк из двух исходных таблиц. В PostgreSQL декартово произведение создается с помощью оператора CROSS JOIN или простого перечисления таблиц в секции FROM без условия соединения.

**Основные принципы работы декартова произведения**

Декартово произведение двух таблиц получается путем сочетания каждой строки первой таблицы с каждой строкой второй таблицы. Если первая таблица содержит m*m* строк, а вторая – n*n* строк, то результатом будет таблица с m×n*m*×*n* строками.

Этот метод полезен, когда необходимо рассмотреть все возможные комбинации данных из двух таблиц. Например, если у вас есть список продуктов и список магазинов, декартово произведение позволит вам увидеть все возможные пары "продукт-магазин".

**Синтаксис:**

```sql
SELECT *

FROM table_1

CROSS JOIN table_2;
```

Или

```sql
SELECT *

FROM table_1, table_2;
```

**Пример:**

Пусть у нас имеются две таблицы: colors (цвета) и shapes (формы).

Таблица colors:

| color_id | color_name |
| -------- | ---------- |
| 1        | красный    |
| 2        | синий      |

Таблица shapes:

| shape_id | shape_name |
| -------- | ---------- |
| A        | круг       |
| B        | квадрат    |

Мы можем создать декартово произведение этих таблиц следующим образом:

Запрос:

```sql
SELECT colors.color_name, shapes.shape_name

FROM colors, shapes;
```

Результат:

| color_name | shape_name |
| ---------- | ---------- |
| красный    | круг       |
| красный    | квадрат    |
| синий      | круг       |
| синий      | квадрат    |

Таким образом, каждая комбинация цвета и формы представлена в результате.

### Заключение

В данном уроке были рассмотрены основные способы работы с множественными запросами в PostgreSQL: объединение таблиц с помощью операторов UNION и UNION ALL, пересечение таблиц оператором INTERSECT, разность таблиц оператором EXCEPT и создание декартовых произведений. Каждый из этих операторов имеет свои особенности и области применения, поэтому важно понимать, какой инструмент лучше всего подходит для конкретной задачи.

Понимание принципов работы этих операторов поможет вам эффективно управлять данными в базе данных, объединяя, пересекая и вычитая наборы данных для решения разнообразных аналитических задач.

## Урок 2: Соединение таблиц

### Введение

Одним из наиболее мощных и широко используемых инструментов в реляционных базах данных является оператор JOIN. Он позволяет объединять данные из двух или более таблиц на основании заданных условий. Оператор JOIN играет ключевую роль в создании сложных запросов, предоставляя пользователям гибкость и эффективность при работе с данными. В данном разделе мы подробно рассмотрим различные виды соединений, их синтаксис, применение и нюансы использования.

### Основы оператора JOIN

Оператор JOIN предназначен для объединения строк из двух и более таблиц в одну результирующую таблицу. Соединения могут выполняться на основании различных критериев, называемых условиями соединения. В зависимости от этих условий и структуры данных, можно выбрать один из множества видов соединений, каждый из которых имеет свои особенности и предназначение.

Основные виды соединений включают:

1. **INNER JOIN** (внутреннее соединение)
2. **LEFT JOIN** / **RIGHT JOIN** («левостороннее» и «правостороннее» соединения)
3. **FULL OUTER JOIN** («полносвязанное» соединение)
4. **CROSS JOIN** (декартово произведение)

Каждый вид соединения имеет свой собственный синтаксис и логику работы, которую мы детально рассмотрим ниже.

### Внутреннее соединение (INNER JOIN)

Внутреннее соединение объединяет строки из двух таблиц, основываясь на условиях, указанных пользователем. В результате возвращаются только те строки, которые удовлетворяют этим условиям. То есть, если строка из одной таблицы не находит соответствия в другой таблице согласно условию соединения, она исключается из результата.

**Синтаксис:**

```sql
SELECT columns

FROM table1

INNER JOIN table2 ON condition;
```

**Пример:**

Рассмотрим две таблицы: orders и customers.

Таблица orders:

| order_id | customer_id | amount |
| -------- | ----------- | ------ |
| 1001     | 1           | 5000   |
| 1002     | 2           | 3000   |
| 1003     | 3           | 2000   |
| 1004     | 1           | 4000   |

Таблица customers:

| customer_id | name   |
| ----------- | ------ |
| 1           | Иван   |
| 2           | Сергей |
| 3           | Ольга  |

Чтобы получить информацию о заказах вместе с именами клиентов, выполним внутреннее соединение:

```sql
SELECT orders.order_id, customers.name, orders.amount

FROM orders

INNER JOIN customers ON orders.customer_id = customers.customer_id;
```

Результат:

| order_id | name   | amount |
| -------- | ------ | ------ |
| 1001     | Иван   | 5000   |
| 1002     | Сергей | 3000   |
| 1003     | Ольга  | 2000   |
| 1004     | Иван   | 4000   |

Как видно, возвращены только те заказы, для которых найдены соответствующие клиенты.

### Левосторонние и правосторонние соединения (LEFT JOIN и RIGHT JOIN)

Левосторонний и правосторонний соединения отличаются тем, что они сохраняют все строки из одной из таблиц (левой или правой соответственно), даже если в другой таблице не найдено соответствие.

**Левостороннее соединение (LEFT JOIN)**

Левостороннее соединение возвращает все строки из левой таблицы, а также совпадающие строки из правой таблицы. Если в правой таблице нет соответствующих строк, вместо них подставляются значения NULL.

**Правостороннее соединение (RIGHT JOIN)**

Правостороннее соединение работает аналогичным образом, но сохраняет все строки из правой таблицы, дополняя их значениями из левой, где возможно.

**Синтаксис левостороннего соединения:**

```sql
SELECT columns

FROM table1

LEFT JOIN table2 ON condition;
```

**Пример левостороннего соединения:**

Добавим в таблицу customers нового клиента, который пока не сделал заказов:

Таблица customers:

| customer_id | name   |
| ----------- | ------ |
| 1           | Иван   |
| 2           | Сергей |
| 3           | Ольга  |
| 4           | Андрей |

Выполнив левостороннее соединение, мы получим следующий результат:

```sql
SELECT customers.name, orders.order_id

FROM customers

LEFT JOIN orders ON customers.customer_id = orders.customer_id;
```

Результат:

| name   | order_id |
| ------ | -------- |
| Иван   | 1001     |
| Иван   | 1004     |
| Сергей | 1002     |
| Ольга  | 1003     |
| Андрей | NULL     |

Андрей появился в списке, хотя у него нет заказов, потому что он находится в левой таблице.

**Аналогично для правосторонних соединений:**

```sql
SELECT columns

FROM table1

RIGHT JOIN table2 ON condition;
```

### Полносвязанные соединения (FULL OUTER JOIN)

Полносвязанное соединение возвращает все строки из обеих таблиц, дополняя их значениями из противоположной таблицы там, где возможно. Если соответствия не находятся, подставляются значения NULL.

**Синтаксис:**

```sql
SELECT columns

FROM table1

FULL OUTER JOIN table2 ON condition;
```

**Пример полносвязанного соединения:**

Вернемся к нашим таблицам orders и customers и выполним полное соединение:

```sql
SELECT customers.name, orders.order_id

FROM customers

FULL OUTER JOIN orders ON customers.customer_id = orders.customer_id;

```

Результат:

| name   | order_id |
| ------ | -------- |
| Иван   | 1001     |
| Иван   | 1004     |
| Сергей | 1002     |
| Ольга  | 1003     |
| Андрей | NULL     |
| NULL   | 1005     |

Здесь добавился новый заказ с order_id=1005, который не был привязан ни к одному клиенту.

### Декартово произведение (CROSS JOIN)

Декартово произведение соединяет каждую строку из одной таблицы с каждой строкой из другой таблицы, создавая все возможные комбинации. Это эквивалентно простому перечислению таблиц в секции FROM без условия соединения.

**Синтаксис:**

```sql
SELECT *

FROM table1

CROSS JOIN table2;
```

**Пример:**

Пусть у нас есть две таблицы: colors и shapes.

Таблица colors:

| color_id | color_name |
| -------- | ---------- |
| 1        | красный    |
| 2        | синий      |

Таблица shapes:

| shape_id | shape_name |
| -------- | ---------- |
| A        | круг       |
| B        | квадрат    |

Мы можем создать декартово произведение этих таблиц следующим образом:

```sql
SELECT colors.color_name, shapes.shape_name

FROM colors

CROSS JOIN shapes;
```

Результат:

| color_name | shape_name |
| ---------- | ---------- |
| красный    | круг       |
| красный    | квадрат    |
| синий      | круг       |
| синий      | квадрат    |

Таким образом, каждая комбинация цвета и формы представлена в результате.

### Заключение

Оператор JOIN является мощным инструментом для работы с реляционными базами данных, позволяя объединять данные из нескольких таблиц на основании различных условий. Понимание принципов работы различных видов соединений (INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL OUTER JOIN, CROSS JOIN) и умение правильно их применять значительно расширит ваши возможности при написании сложных запросов и анализе данных.

## Урок 3: Вложенные подзапросы

### Введение

Подзапросы — это запросы внутри другого запроса, которые помогают извлекать данные из одной или нескольких таблиц и использовать их в основном запросе. Подзапросы могут использоваться практически со всеми операторами SQL, включая SELECT, INSERT, UPDATE, DELETE, а также в конструкциях WHERE, HAVING, EXISTS, IN, ANY, ALL и многих других. Они предоставляют мощный механизм для выполнения сложных операций с данными, позволяя разбивать задачу на отдельные шаги и улучшать читаемость кода.

В этом разделе мы подробно рассмотрим, как работают вложенные подзапросы, с какими операторами они сочетаются, их классификацию и использование различных предикатов.

### Основы вложенных подзапросов

Вложенный подзапрос — это запрос, заключённый в круглые скобки и выполняемый перед основным запросом. Результат подзапроса затем используется в основном запросе для дальнейшей обработки данных. Важно отметить, что подзапрос выполняется только один раз, независимо от количества строк в основной таблице.

**Синтаксис:**

```sql
SELECT columns

FROM table

WHERE condition (подзапрос);
```

**Пример:**

Рассмотрим две таблицы: employees и departments.

Таблица employees:

| employee_id | department_id | salary |
| ----------- | ------------- | ------ |
| 1           | 10            | 5000   |
| 2           | 20            | 6000   |
| 3           | 30            | 7000   |

Таблица departments:

| department_id | department_name |
| ------------- | --------------- |
| 10            | Sales           |
| 20            | Marketing       |
| 30            | IT              |

Для того чтобы найти сотрудников, работающих в отделе с названием 'IT', используем подзапрос:

```sql
SELECT employee_id, salary

FROM employees

WHERE department_id IN (

    SELECT department_id

    FROM departments

    WHERE department_name = 'IT'
);
```

Результат:

| employee_id | salary |
| ----------- | ------ |
| 3           | 7000   |

Здесь подзапрос сначала находит идентификатор отдела 'IT' (это значение равно 30), после чего основной запрос использует этот идентификатор для поиска соответствующего сотрудника.

### Классификация подзапросов

Подзапросы можно разделить на несколько категорий в зависимости от их поведения и назначения:

- Коррелированные подзапросы:

  - Выполняются для каждой строки основного запроса.
  - Используют данные из внешнего запроса для своей работы.

- Некоррелированные подзапросы:

  - Выполняются только один раз и их результат используется многократно.
  - Не зависят от внешних данных.

- Однострочные подзапросы:

  - Возвращают ровно одну строку.

- Многострочные подзапросы:

  - Могут вернуть любое количество строк.

- Скалярные подзапросы:

  - Возвратят одно значение (одну ячейку).

- Табличные подзапросы:
  - Вернут множество строк и столбцов.

### Операции с подзапросами

Подзапросы могут использоваться совместно с различными операторами SQL для достижения различных целей:

1. Операция SELECT:

   ```sql
   SELECT (подзапрос) AS alias;
   ```

2. Условия WHERE:

- Подзапросы часто используются в условиях WHERE, чтобы ограничить выборку данных:
  - IN:
    ```sql
    WHERE column IN (подзапрос);
    ```
  - NOT IN:
    ```sql
    WHERE column NOT IN (подзапрос);
    ```
  - EXISTS (проверяет наличие хотя бы одной строки, соответствующей критерию):
    ```sql
    EXISTS (подзапрос);
    ```

3. Предикат ANY/SOME:

- Используется для сравнения значений с результатами подзапроса:
  ```sql
  WHERE column > ANY (подзапрос); -- true, если хотя бы одно значение больше
  ```

4. Предикат ALL:

- Проверяет выполнение условия для всех строк подзапроса:
  ```sql
  WHERE column >= ALL (подзапрос);
  ```

5. Конструкции HAVING:

- Позволяют фильтровать группы данных после группировки:
  ```sql
  HAVING (подзапрос) > value;
  ```

6. Вставка данных (INSERT INTO ... SELECT):

- Можно вставлять данные из одного источника в другую таблицу, используя подзапрос:

  ```sql
  INSERT INTO target_table (columns)

  SELECT columns

  FROM source_table

  WHERE condition;
  ```

7. Обновление данных (UPDATE ... SET):

- Обновить данные в таблице на основе результатов подзапроса:

  ```sql
  UPDATE table

  SET column = (подзапрос)

  WHERE condition;
  ```

8. Удаление данных (DELETE ... WHERE):

- Удалить строки на основе результата подзапроса:

  ```sql
  DELETE FROM table

  WHERE id IN (подзапрос);
  ```

### Заключение

Использование вложенных подзапросов открывает широкие возможности для работы с данными в реляционных базах данных. Они позволяют структурировать сложные запросы, делая код более читаемым и поддерживаемым. Знание различных типов подзапросов и способов их применения с основными операторами SQL существенно повышает уровень владения языком запросов и делает работу с данными более эффективной.

---

## Практика: Многотабличные запросы в базе данных PostgreSQL

**Порядок работы**

1. **Запуск PostgreSQL и подключение к базе данных**

Для начала работы с PostgreSQL подключитесь к базе данных по умолчанию (например, postgres) через утилиту командной строки psql или интерфейс, запустите редактор SQL-запросов.

2. **Создание базы данных**

Убедитесь, что существует база данных ShopBD.

3. **Создание таблицы**

Убедитесь, что существует таблица Goods со следующими свойствами (при необходимости, добавьте указанную таблицу):

| Атрибут | Описание\*          | Тип           | Уникальность | По умолчанию | Пустые значения | Условие      |
| ------- | ------------------- | ------------- | ------------ | ------------ | --------------- | ------------ |
| DeptID  | Номер отдела        | int           |              | 1            | NOT NULL        | `>=1 и <=10` |
| GoodID  | Номер товара        | int           | PK           |              | NOT NULL        |              |
| GName   | Наименование товара | varchar(20)   | Unique\*\*   |              | NOT NULL        |              |
| Descr   | Описание товара     | varchar(20)   |              | NULL         |                 |
| Price   | Цена                | DECIMAL(10,4) |              |              | NOT NULL        | `>0`         |
| GCount  | Количество          | int           |              |              | NOT NULL        | `>0`         |

`*` Столбец Описание приведен для информации об атрибутах и никак не участвует при создании таблицы.  
`**` Уникальной является пара значений атрибутов, а не отдельные атрибуты.

**Команда для создания таблицы:**

```sql
CREATE TABLE Goods (

    DeptID INT NOT NULL DEFAULT 1 CHECK (DeptID >= 1 AND DeptID <= 10),

    GoodID SERIAL PRIMARY KEY,

    GName VARCHAR(20) NOT NULL,

    Descr VARCHAR(50) NULL,

    Price DECIMAL(10, 4) NOT NULL CHECK (Price > 0),

    GCount INT NOT NULL CHECK (GCount > 0),

    CONSTRAINT Unique_GoodID_GName UNIQUE (GoodID, GName)
);

```

4. Создайте таблицу Departments со следующими свойствами:

| Атрибут  | Описание            | Тип         | Уникальность | По умолчанию | NULL значения | Условие      |
| -------- | ------------------- | ----------- | ------------ | ------------ | ------------- | ------------ |
| DeptID   | Номер отдела        | int         | PK           |              | Not null      | `>=1 и <=10` |
| DeptName | Наименование отдела | varchar(50) |              |              | Not null      |              |

```sql
CREATE TABLE Departments (

    DeptID INT NOT NULL CHECK (DeptID >= 1 AND DeptID <= 10),

    DeptName VARCHAR(50) NOT NULL
);
```

5. Заполните таблицу Departments (Отделы) в БД ShopDB, пользуясь командой INSERT, таким образом, чтобы в ней оказались только те номера отделов, которые есть в таблице Goods, а названия отделов DeptName заполнялись бы пустой строкой.

```sql
INSERT INTO Departments (DeptID, DeptName)

SELECT DISTINCT DeptID, '' FROM Goods;
```

6. Заполните названия отделов в таблице Departmnets.

```sql
UPDATE Departments

SET DeptName = ('Канцтовары')

WHERE DeptID = 1;
```

```sql
UPDATE Departments

SET DeptName = ('Бытовая химия')

WHERE DeptID = 2;
```

```sql
UPDATE Departments

SET DeptName = ('Хлебный')

WHERE DeptID = 3;
```

7. Выведите декартово произведение таблиц Departments и Goods, т.е. всевозможные сочетания их строк.

```sql
SELECT * FROM Departments CROSS JOIN Goods;
```

8. Добавьте в предыдущую команду условие соединения по столбцу DeptID и снова выполните команду. Условие соединения формулируйте с помощью WHERE.

```sql
SELECT * FROM Departments CROSS JOIN Goods

WHERE Departments.DeptID = Goods.DeptID;
```

9. Выполните внутреннее соединение таблиц Departments и Goods по столбцу DeptID, используя синтаксис соединенных таблиц (JOIN). Есть ли разница в результирующей таблице по сравнению с п.8?

```sql
SELECT * FROM Departments INNER JOIN Goods ON Departments.DeptID = Goods.DeptID;
```

10. Добавьте новый отдел в таблицу Departments.

```sql
INSERT INTO Departments (DeptID, DeptName)

VALUES (4, 'Овощи');
```

11. Выполните левое внешнее соединение (LEFT JOIN) таблиц Departments и Goods по столбцу DeptID. Что изменилось по сравнению с внутренним соединением п.9?

```sql
SELECT * FROM Departments LEFT JOIN Goods ON Departments.DeptID = Goods.DeptID;
```

12. Добавьте теперь новый товар в таблицу Goods, продающийся в отделе, которого нет в таблице Departments.

```sql
INSERT INTO Goods (DeptID, gname, descr, price, gcount)

VALUES (3, 'Сок', 'Апельсиновый', 30, 10);
```

13. Выполните правое внешнее соединение (RIGHT JOIN) таблиц Departments и Goods по столбцу DeptID.

```sql
SELECT * FROM Departments RIGHT JOIN Goods ON Departments.DeptID = Goods.DeptID;
```

14. Выполните полное соединение (FULL JOIN) таблиц Departments и Goods по столбцу DeptID.

```sql
SELECT * FROM Departments FULL JOIN Goods ON Departments.DeptID = Goods.DeptID;
```

15. Выведите все отделы и все товары, для которых не найдено соответствия в другой таблице. Иными словами, нужно вывести отделы из Departments, для которых нет товаров в таблице Goods и товары из Goods с номером отдела, которого нет в таблице Departments. Запрос формулируйте с помощью соединений и разности EXCEPT.

```sql
SELECT Departments.DeptID, Departments.DeptName, Goods.GoodID, Goods.gName

FROM Departments

LEFT JOIN Goods ON Departments.DeptID = Goods.DeptID

EXCEPT

SELECT Departments.DeptID, Departments.DeptName, Goods.GoodID, Goods.gName

FROM Departments

RIGHT JOIN Goods ON Departments.DeptID = Goods.DeptID;
```

16. Выведите все отделы (номера и наименования), в которых продается хотя бы 1 товар. Запрос выполните тремя способами на выбор: используя соединение, используя подзапросы с IN или EXISTS, используя сравнение с квантором ANY (SOME), используя агрегатную функцию СOUNT().

```sql
SELECT * FROM departments;

SELECT * FROM goods;
```

- Используя соединение

```sql
SELECT DISTINCT Departments.DeptID, Departments.DeptName

FROM Departments

INNER JOIN Goods ON Departments.DeptID = Goods.DeptID;
```

- Используя подзапросы с IN или EXISTS

```sql
SELECT Departments.DeptID, Departments.DeptName

FROM Departments

WHERE EXISTS (SELECT 1 FROM Goods WHERE Goods.DeptID = Departments.DeptID);
```

- Используя сравнение с квантором ANY(SOME)

```sql
SELECT Departments.DeptID, Departments.DeptName

FROM Departments

WHERE Departments.DeptID = ANY (SELECT Goods.DeptID FROM Goods);
```

- Используя агрегатную функцию СOUNT()

```sql
SELECT Departments.DeptID, Departments.DeptName

FROM Departments

JOIN Goods on Goods.DeptId = Departments.DeptID

GROUP BY Departments.DeptID, Departments.DeptName

HAVING COUNT(Goods.GoodID) > 0;
```

17. Для каждого отдела вычислите суммарную стоимость проданного товара и выведите номера и названия этих отделов.

```sql
SELECT Departments.DeptID, Departments.DeptName, SUM(Goods.Price * Goods.gCount) AS TotalPrice

FROM Departments

INNER JOIN Goods ON Departments.DeptID = Goods.DeptID

GROUP BY Departments.DeptID, Departments.DeptName;
```

18. Выведите номер и название отдела, где суммарная стоимость проданного товара максимальна.

```sql
SELECT Departments.DeptID, Departments.DeptName

FROM Departments

INNER JOIN Goods ON Departments.DeptID = Goods.DeptID

GROUP BY Departments.DeptID, Departments.DeptName

ORDER BY SUM(Goods.Price * Goods.gCount) DESC

LIMIT 1;
```

19. Выведите два отдела (номера и названия) с наибольшими суммами проданного товара.

```sql
SELECT Departments.DeptID, Departments.DeptName

FROM Departments

INNER JOIN Goods ON Departments.DeptID = Goods.DeptID

GROUP BY Departments.DeptID, Departments.DeptName

ORDER BY SUM(Goods.Price * Goods.gCount) DESC

LIMIT 2;
```

20. Вычислите для каждого товара процентное отношение его стоимости от суммарной стоимости товаров в соответствующем отделе. Выведите код, наименование товара и вычисленный процент.

```sql
WITH cte AS (

    SELECT DeptId, SUM(G.Price * G.Gcount) as Total FROM Goods G GROUP BY DeptId
)

SELECT

Goods.GoodId,

Goods.GName,

Goods.Descr,

Goods.Price / cte.Total * 100 AS Percentage

FROM Goods

JOIN cte ON cte.DeptId = Goods.DeptId;
```

21. Повысьте цены на все товары на 10% относительно средней цены на товар по всей таблице Goods (используя команду UPDATE).

```sql
UPDATE Goods

SET Price = Price + (SELECT AVG(Price) FROM Goods) * 0.1;
```

22. В новую таблицу Discount запишите все сведения о товарах, а также сумму скидки, которая вычисляется в зависимости от цены товара:
    - `если цена < 10р, то скидка = 20% от цены;`
    - `если 10р <= цена <= 50р, то скидка = 10% от цены;`
    - `если цена > 50р, то скидка = 5% от цены.`

- Создание новой таблицы Discount

```sql
CREATE TABLE Discount (

    GoodId INT,

    Dname VARCHAR(50),

    Price DECIMAL(10, 2),

    Discount DECIMAL(10, 2)
);
```

- Вставка данных в таблицу Discount

```sql
INSERT INTO Discount (GoodId, Dname, Price)

SELECT Goods.GoodId, CONCAT(Goods.GName, ' ', Goods.Descr), Goods.Price

FROM Goods;
```

- Вычисление скидок и вставка их в таблицу Discount

```sql
UPDATE Discount

SET Discount = CASE

    WHEN Price < 10 THEN Price * 0.2

    WHEN Price BETWEEN 10 AND 50 THEN Price * 0.1

    WHEN Price > 50 THEN Price * 0.05

END;
```

23. Завершение работы

После выполнения всех шагов сохраните скрипт лабораторной работы для отчёта.
