# Лабораторная работа 2 - Создание типов данных и таблиц

## Урок 1: Создание типов данных в PostgreSQL

**Цели урока:**

- Изучить системные типы данных, поддерживаемые PostgreSQL.
- Научиться создавать собственные (пользовательские) типы данных.
- Понять, в каких ситуациях следует создавать пользовательские типы данных.

---

### Введение

В PostgreSQL данные хранятся в таблицах, и каждый столбец таблицы должен иметь определённый тип данных. Тип данных определяет, какие значения могут храниться в столбце и как они будут обрабатываться. PostgreSQL предлагает широкий выбор предопределённых системных типов данных, а также позволяет создавать собственные типы, чтобы лучше соответствовать требованиям приложения.

### Системные типы данных в PostgreSQL

PostgreSQL поддерживает множество встроенных типов данных:

1. **Числовые типы данных**:
   - INTEGER, BIGINT — для хранения целых чисел.
   - NUMERIC(precision, scale) — для хранения чисел с фиксированной точностью, подходит для финансовых расчётов.
   - SERIAL — автоинкрементный целый тип данных.
2. **Строковые типы данных**:
   - VARCHAR(n) — строка переменной длины с ограничением.
   - TEXT — строка произвольной длины.
3. **Временные типы данных**:
   - DATE — для хранения даты.
   - TIMESTAMP — для хранения даты и времени с точностью до микросекунд.
4. **Специальные типы данных**:
   - BOOLEAN — для хранения логических значений (true/false).
   - ARRAY — массивы данных.
   - JSON и JSONB — для хранения данных в формате JSON.

### Создание пользовательских типов данных

Пользовательские типы данных (Custom Data Types) позволяют создавать на основе существующих системных типов новые типы с ограничениями или определёнными правилами использования. Это помогает стандартизировать данные и облегчить управление ими.

**Пример: создание пользовательского типа данных для кода страны**

Допустим, в базе данных необходимо хранить коды стран в формате ISO-3166 (двухсимвольные коды, такие как RU, US).

```sql
CREATE TYPE country_code AS ENUM ('RU', 'US', 'CN', 'DE', 'FR');
```

Этот тип данных можно использовать для хранения кодов стран в таблице, что гарантирует, что только определённые значения могут быть введены в столбец.

### Использование псевдонимов типов данных

Псевдонимы (или алиасы) для типов данных — это пользовательские типы, которые создаются на основе системных. Они могут быть полезны для стандартизации данных. Например, можно создать псевдоним для телефонного номера, чтобы использовать его во многих таблицах.

### Пример создания псевдонима типа данных:

```sql
CREATE DOMAIN phone_number AS VARCHAR(15) CHECK (VALUE ~ '^[0-9]{10,15}$');
```

Здесь создаётся псевдоним phone_number, который ограничивает введённые значения только числами и проверяет длину.

### Когда следует создавать пользовательские типы данных?

Создание собственных типов данных целесообразно в следующих ситуациях:

- Когда необходимо стандартное представление данных (например, коды стран, телефонные номера).
- Когда требуется более строгий контроль за данными, чем обеспечивается системными типами.
- Когда используется часто повторяющийся элемент данных, который нужно стандартизировать по всей базе данных.

### Заключение

Использование как системных, так и пользовательских типов данных помогает эффективно организовать структуру базы данных и улучшить её читаемость, управляемость и согласованность данных.

---

## Урок 2: Создание таблиц в PostgreSQL

**Цели урока:**

- Научиться создавать таблицы в PostgreSQL.
- Рассмотреть различные типы данных, используемые в таблицах.
- Узнать, как добавлять и изменять столбцы, применять ограничения.
- Изучить, как обеспечивать целостность данных с помощью ключей.

---

### Введение

Таблицы являются основными объектами базы данных, в которых хранятся все данные. Каждая таблица состоит из строк и столбцов, где строки представляют записи, а столбцы — это атрибуты (поля) этих записей. В PostgreSQL создание таблицы требует указания имени столбцов и типов данных, а также настройки ограничений для поддержания целостности данных.

### Создание таблицы

Чтобы создать таблицу, используется команда CREATE TABLE. При создании таблицы нужно указать имена столбцов и их типы данных, а также определить ключевые ограничения, такие как первичный ключ и возможность пустых значений.

**Пример создания простой таблицы:**

```sql
CREATE TABLE employees (

    employee_id SERIAL PRIMARY KEY,

    first_name VARCHAR(50) NOT NULL,

    last_name VARCHAR(50) NOT NULL,

    hire_date DATE,

    salary NUMERIC(10, 2)

);
```

- SERIAL — автоинкрементное поле для создания уникальных идентификаторов записей (аналог AUTO_INCREMENT).
- PRIMARY KEY — ключевое ограничение, которое гарантирует уникальность каждого значения в столбце employee_id.
- NOT NULL — указывает, что столбцы first_name и last_name не могут содержать пустые значения.
- NUMERIC(10, 2) — тип данных для зарплаты с двумя знаками после запятой.

### Ограничения и ключи

PostgreSQL поддерживает различные ограничения для обеспечения целостности данных:

- **PRIMARY KEY** — уникальный идентификатор строки (как в примере выше).
- **FOREIGN KEY** — внешний ключ для установления связи между таблицами.
- **UNIQUE** — ограничение, которое гарантирует уникальность значений в столбце.
- **NOT NULL** — предотвращает вставку пустых значений в столбец.
- **CHECK** — задаёт условие, которое должно быть выполнено для значений в столбце.

**Пример с использованием внешнего ключа и ограничения CHECK:**

```sql
CREATE TABLE departments (

    department_id SERIAL PRIMARY KEY,

    department_name VARCHAR(100) NOT NULL

);
```

```sql
CREATE TABLE employees (

    employee_id SERIAL PRIMARY KEY,

    first_name VARCHAR(50) NOT NULL,

    last_name VARCHAR(50) NOT NULL,

    hire_date DATE,

    salary NUMERIC(10, 2) CHECK (salary > 0),

    department_id INT REFERENCES departments(department_id)

);
```

В этом примере:

- Столбец salary должен содержать положительное значение, что контролируется через ограничение CHECK.
- Столбец department_id в таблице employees связан с таблицей departments через внешний ключ REFERENCES.

### Изменение таблицы

Иногда необходимо добавить новые столбцы, изменить существующие или удалить ненужные. Для этого используется команда ALTER TABLE.

**Пример добавления нового столбца:**

```sql
ALTER TABLE employees ADD COLUMN email VARCHAR(100);
```

**Пример изменения типа данных столбца:**

```sql
ALTER TABLE employees ALTER COLUMN salary TYPE NUMERIC(12, 2);
```

**Пример удаления столбца:**

```sql
ALTER TABLE employees DROP COLUMN email;
```

### Удаление таблицы

Если таблица больше не нужна, её можно удалить с помощью команды DROP TABLE.

**Пример удаления таблицы:**

```sql
DROP TABLE employees;
```

### Создание временных таблиц

PostgreSQL поддерживает временные таблицы, которые существуют только в рамках текущей сессии. Они полезны для хранения временных данных, которые не нужны после завершения сессии.

**Пример создания временной таблицы:**

```sql
CREATE TEMPORARY TABLE temp_employees (

    employee_id SERIAL,

    first_name VARCHAR(50),

    last_name VARCHAR(50)

);
```

Временные таблицы автоматически удаляются, когда сессия закрывается.

### Индексы

Индексы используются для ускорения операций поиска. PostgreSQL позволяет создавать индексы на один или несколько столбцов.

**Пример создания индекса:**

```sql
CREATE INDEX idx_employee_name

ON employees (last_name, first_name);
```

Этот индекс ускоряет выполнение запросов, которые используют столбцы last_name и first_name для поиска.

### Заключение

Создание таблиц — это основополагающая часть проектирования базы данных. Важно правильно выбирать типы данных для каждого столбца, а также использовать ограничения и ключи для поддержания целостности данных и обеспечения эффективности запросов.

---

## Урок 3: Создание секционированных таблиц в PostgreSQL

**Цели урока:**

- Научиться создавать секционированные таблицы в PostgreSQL.
- Узнать, как организовать данные в таблицах с секционированием для повышения производительности и управляемости.
- Рассмотреть сценарии, в которых полезно применять секционирование.

---

### Введение

Секционирование (partitioning) — это метод разделения больших таблиц на более мелкие части, называемые секциями, которые хранятся и управляются отдельно. Секционирование может улучшить производительность запросов и упростить администрирование больших объёмов данных. В PostgreSQL секционирование осуществляется горизонтально, то есть строки таблицы распределяются по секциям на основе значений определённого столбца (например, даты или числового идентификатора).

Секционированные таблицы используются для оптимизации запросов, улучшения масштабируемости и удобного управления архивными данными.

### Виды секционирования в PostgreSQL

PostgreSQL поддерживает несколько видов секционирования:

1. **Секционирование по диапазону значений** (RANGE): данные распределяются по секциям на основе диапазонов значений столбца (например, даты или числового идентификатора).
2. **Секционирование по списку значений** (LIST): строки распределяются в секции по конкретным значениям (например, по категориям или регионам).
3. **Хэш-секционирование** (HASH): строки распределяются по секциям с использованием хэш-функций.

### Создание секционированных таблиц

Для создания секционированной таблицы необходимо указать ключ секционирования (столбец, по которому будут распределяться данные) и тип секционирования.

**Пример создания секционированной таблицы по диапазону дат:**

```sql
CREATE TABLE orders (

    order_id SERIAL PRIMARY KEY,

    order_date DATE NOT NULL,

    customer_id INT,

    amount NUMERIC(10, 2)

) PARTITION BY RANGE (order_date);
```

В этом примере таблица orders будет разделена по столбцу order_date, а строки будут помещаться в соответствующие секции на основе значения даты заказа.

**Создание секций**

После создания секционированной таблицы необходимо создать секции (подтаблицы) с указанием диапазонов значений или других условий.

**Пример создания секций для заказов за разные годы:**

```sql
CREATE TABLE orders_2022 PARTITION OF orders

FOR VALUES FROM ('2022-01-01') TO ('2022-12-31');
```

```sql
CREATE TABLE orders_2023 PARTITION OF orders

FOR VALUES FROM ('2023-01-01') TO ('2023-12-31');
```

Здесь создаются две секции: orders_2022 для заказов, сделанных в 2022 году, и orders_2023 для заказов за 2023 год.

**Секционирование по списку**

Секционирование по списку используется для распределения строк по фиксированным значениям, например, по категориям или регионам.

**Пример секционирования по списку значений (страны):**

```sql
CREATE TABLE sales (

    sale_id SERIAL PRIMARY KEY,

    country_code CHAR(2),

    sale_amount NUMERIC(10, 2)

) PARTITION BY LIST (country_code);
```

```sql
CREATE TABLE sales_usa PARTITION OF sales

FOR VALUES IN ('US');
```

```sql
CREATE TABLE sales_canada PARTITION OF sales

FOR VALUES IN ('CA');
```

Здесь создаются секции для продаж в США (sales_usa) и Канаде (sales_canada).

### Хэш-секционирование

Хэш-секционирование полезно, когда данные не могут быть логически разделены на диапазоны или списки. PostgreSQL распределяет строки по секциям с использованием хэш-функций.

**Пример хэш-секционирования по идентификатору клиента:**

```sql
CREATE TABLE customers (

    customer_id SERIAL PRIMARY KEY,

    customer_name VARCHAR(100)

) PARTITION BY HASH (customer_id);
```

```sql
CREATE TABLE customers_part1 PARTITION OF customers

FOR VALUES WITH (MODULUS 4, REMAINDER 0);
```

```sql
CREATE TABLE customers_part2 PARTITION OF customers

FOR VALUES WITH (MODULUS 4, REMAINDER 1);
```

Здесь PostgreSQL распределяет клиентов по секциям на основе значения хэш-функции для столбца customer_id.

**Управление секциями**

PostgreSQL позволяет выполнять операции с секциями, такие как добавление, удаление или объединение секций.

- **Добавление секции**: Если данные выходят за пределы диапазона, определённого для существующих секций, необходимо создать новую секцию.

**Пример добавления новой секции:**

```sql
CREATE TABLE orders_2024 PARTITION OF orders

FOR VALUES FROM ('2024-01-01') TO ('2024-12-31');
```

- **Удаление секции**: Чтобы удалить секцию, используется команда DROP TABLE.

```sql
DROP TABLE orders_2022;
```

- **Объединение секций**: В некоторых случаях можно объединить секции для упрощения управления.

**Преимущества секционирования**

Секционирование обеспечивает следующие преимущества:

1. **Ускорение выполнения запросов**: Запросы могут быть ограничены определённой секцией, что уменьшает объём данных для обработки.
2. **Упрощённое управление данными**: Легко архивировать старые данные или проводить резервное копирование и восстановление отдельных секций.
3. **Меньшая фрагментация**: Каждая секция может управляться отдельно, что снижает вероятность фрагментации данных.

### Заключение

Секционирование — мощный инструмент для управления большими наборами данных. Оно помогает улучшить производительность запросов, упростить управление и увеличить масштабируемость баз данных. В PostgreSQL секционирование может быть реализовано различными способами, в зависимости от структуры данных и требований приложения.

---

## Практика: Создание типов данных и таблиц в PostgreSQL

**Порядок работы**

1. **Запуск PostgreSQL и подключение к базе данных**

Для начала работы с PostgreSQL подключитесь к базе данных по умолчанию (например, postgres) через утилиту командной строки psql или интерфейс, такой как pgAdmin.

В командной строке psql подключение выполняется командой:

```bash
\c postgres
```

2. **Создание базы данных**

Создайте новую базу данных с именем BookshopDB с параметрами по умолчанию:

```sql
CREATE DATABASE BookshopDB;
```

Подключитесь к созданной базе данных:

```bash
\c BookshopDB
```

3. **Создание таблицы Authors**

Создайте таблицу Authors со следующими свойствами:

    * AuthorID: автоинкрементное поле, используется как первичный ключ.
    * FirstName, LastName, YearBorn, YearDied — текстовые поля с различными ограничениями.

<table>
  <tr>
   <td>
    <strong>Поле</strong>
   </td>
   <td>
    <strong>Тип данных</strong>
   </td>
   <td>
    <strong>Null</strong>
   </td>
   <td>
    <strong>По умолчанию</strong>
   </td>
  </tr>
  <tr>
   <td>
    AuthorID
   </td>
   <td>
    int
   </td>
   <td>
    not null
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    FirstName
   </td>
   <td>
    varchar(30)
   </td>
   <td>
    not null
   </td>
   <td>
    ‘unknown’
   </td>
  </tr>
  <tr>
   <td>
    LastName
   </td>
   <td>
    varchar(30)
   </td>
   <td>
    null
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    YearBorn
   </td>
   <td>
    char(4)
   </td>
   <td>
    null
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    YearDied
   </td>
   <td>
    char(4)
   </td>
   <td>
    not null
   </td>
   <td>
    ‘no’
   </td>
  </tr>
</table>

**Команда для создания таблицы:**

```sql
CREATE TABLE Authors (

    AuthorID SERIAL PRIMARY KEY,

    FirstName VARCHAR(30) NOT NULL DEFAULT 'unknown',

    LastName VARCHAR(30),

    YearBorn CHAR(4),

    YearDied CHAR(4) NOT NULL DEFAULT 'no'

);
```

4. **Проверка свойств таблицы**

Используйте команду \d Authors для просмотра структуры таблицы Authors. Также можно выполнить SQL-запрос к системным каталогам:

```sql
SELECT * FROM information_schema.columns WHERE table_name = 'authors';
```

5. **Добавление нового столбца**

Добавьте в таблицу Authors новый столбец Descr (описание автора) длиной до 200 символов:

```sql
ALTER TABLE Authors ADD COLUMN Descr VARCHAR(200) NOT NULL;
```

6. **Создание таблицы Books**

Создайте таблицу Books со следующими свойствами:

    * BookID: автоинкрементное поле, используется как первичный ключ.
    * Title: строка длиной до 100 символов, обязательное поле.
    * Genre: строка длиной до 50 символов.

<table>
  <tr>
   <td>
    <strong>Поле</strong>
   </td>
   <td>
    <strong>Тип данных</strong>
   </td>
   <td>
    <strong>Null</strong>
   </td>
   <td>
    <strong>Уникальность</strong>
   </td>
  </tr>
  <tr>
   <td>
    BookID
   </td>
   <td>
    int
   </td>
   <td>
    not null
   </td>
   <td>
    Primary key
   </td>
  </tr>
  <tr>
   <td>
    Title
   </td>
   <td>
    varchar(100)
   </td>
   <td>
    not null
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>
    Genre
   </td>
   <td>
    varchar(50)
   </td>
   <td>
    null
   </td>
   <td>
   </td>
  </tr>
</table>

**Команда для создания таблицы:**

```sql
CREATE TABLE Books (

    BookID SERIAL PRIMARY KEY,

    Title VARCHAR(100) NOT NULL,

    Genre VARCHAR(50)

);
```

7. **Создание таблицы BookAuthor**

Создайте таблицу BookAuthor, в которой будут храниться связи между книгами и авторами:

<table>
  <tr>
   <td>
    <strong>Поле</strong>
   </td>
   <td>
    <strong>Тип данных</strong>
   </td>
   <td>
    <strong>Null</strong>
   </td>
  </tr>
  <tr>
   <td>
    BookID
   </td>
   <td>
    int
   </td>
   <td>
    not null
   </td>
  </tr>
  <tr>
   <td>
    AuthorID
   </td>
   <td>
    int
   </td>
   <td>
    not null
   </td>
  </tr>
</table>

```sql
CREATE TABLE BookAuthor (

    BookID INT NOT NULL,

    AuthorID INT NOT NULL

);
```

8. **Добавление первичного ключа**

В таблице BookAuthor первичный ключ должен состоять из обоих столбцов (BookID и AuthorID).

**Команда для добавления первичного ключа:**

```sql
ALTER TABLE BookAuthor ADD PRIMARY KEY (BookID, AuthorID);
```

9. **Добавление внешнего ключа для связи с таблицей Books**

Свяжите таблицу Books и BookAuthor, добавив внешнее ограничение на BookID:

```sql
ALTER TABLE BookAuthor

ADD CONSTRAINT fk_book FOREIGN KEY (BookID) REFERENCES Books(BookID);
```

10. **Добавление внешнего ключа для связи с таблицей Authors**

Свяжите таблицу Authors и BookAuthor, добавив внешнее ограничение на AuthorID:

```sql
ALTER TABLE BookAuthor

ADD CONSTRAINT fk_author FOREIGN KEY (AuthorID) REFERENCES Authors(AuthorID);
```

11. **Добавление проверочных ограничений для YearBorn**

Для столбца YearBorn добавьте ограничение, которое проверяет формат года:

```sql
ALTER TABLE Authors ADD CONSTRAINT chk_yearborn CHECK (YearBorn ~ '^[12][06-9][0-9]{2}$');
```

12. **Добавление проверочного ограничения для YearDied**

Добавьте ограничение для столбца YearDied, которое допускает либо значение в формате года, либо значение 'no':

```sql
ALTER TABLE Authors ADD CONSTRAINT chk_yeardied CHECK (YearDied ~ '^[12][06-9][0-9]{2}$' OR YearDied = 'no');
```

13. **Добавление ограничения на связь дат рождения и смерти**

Добавьте проверочное ограничение, которое гарантирует, что год смерти больше года рождения:

```sql
ALTER TABLE Authors ADD CONSTRAINT chk_life_dates CHECK (YearDied > YearBorn OR YearDied = 'no');
```

14. **Заполнение таблиц данными**

Вставьте несколько строк в таблицы с помощью команды INSERT:

```sql
INSERT INTO Authors (FirstName, LastName, YearBorn, YearDied, Descr)

VALUES ('Mark', 'Twain', '1835', '1910', 'American writer');
```

**Пример вставки данных в таблицу Books:**

```sql
INSERT INTO Books (Title, Genre)

VALUES ('The Adventures of Tom Sawyer', 'Adventure');
```

15. **Проверка ошибок при вставке данных**

Обратите внимание на сообщения об ошибках при нарушении ограничений целостности. Например, если год рождения указан неверно, вы получите сообщение о нарушении ограничения chk_yearborn.

16. **Завершение работы**

После выполнения всех шагов сохраните скрипт лабораторной работы для отчёта.
