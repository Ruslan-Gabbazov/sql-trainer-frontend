---
sidebar_position: 3
---

# Лабораторная работа 3 - Манипулирование данными

## Урок 1: Использование команд манипулирования данными.

**Цели урока:**

- Как правильно использовать команды INSERT, UPDATE, DELETE.
- Синтаксические особенности этих команд.
- Примеры использования каждого оператора.
- Когда и зачем применять эти операторы.

---

### Введение

PostgreSQL — одна из самых популярных систем управления базами данных (СУБД), которая предоставляет мощные инструменты для работы с реляционными данными. Одной из ключевых задач при работе с базой данных является управление данными: добавление новых записей, изменение существующих и удаление ненужных. Для этого используются команды INSERT, UPDATE и DELETE. Эти команды позволяют выполнять операции над таблицами базы данных, изменяя содержимое данных.

### Команда INSERT

Команда INSERT предназначена для добавления одной или нескольких строк в таблицу базы данных. Она позволяет вставить новые данные в существующую таблицу.

**Синтаксис:**

```sql
INSERT INTO имя_таблицы [(имя_столбца1, имя_столбца2, ...)]

VALUES (значение1, значение2, ...);
```

или

```sql
INSERT INTO имя_таблицы [(имя_столбца1, имя_столбца2, ...)]

SELECT выражение1, выражение2, ...

FROM другая_таблица

WHERE условие;
```

**Описание элементов синтаксиса:**

- имя_таблицы — название таблицы, в которую будут добавлены записи.
- (имя*столбца1, имя*столбца2, ...) (необязательно) — список столбцов, куда нужно добавить значения. Если этот список отсутствует, то подразумевается, что данные должны заполнять все столбцы таблицы в том порядке, в котором они были определены при создании таблицы.
- VALUES (значение1, значение2,...) — перечисленные через запятую значения, которые будут вставлены в соответствующие столбцы.
- Альтернативный вариант — использование подзапросов (SELECT) для вставки данных из другой таблицы.

**Примеры использования оператора INSERT:**

**Пример 1: добавляем одну строку в таблицу users:**

```sql
INSERT INTO users (id, name, email)

VALUES (1, 'Иван Иванов', 'ivan@example.com');
```

Здесь происходит вставка значений в три столбца: id, name и email.

**Пример 2: Добавляем несколько строк за раз:**

```sql
INSERT INTO users (id, name, email)

VALUES

    (2, 'Петр Петров', 'petr@example.com'),

    (3, 'Анна Сидорова', 'anna@example.com');
```

Этот запрос добавляет сразу две строки в таблицу.

**Пример 3: Использование подзапроса для вставки:**

```sql
INSERT INTO users (id, name, email)

SELECT id, full_name, email

FROM user_profiles

WHERE is_active = true;
```

Запрос выбирает данные из таблицы user_profiles и вставляет их в таблицу users.

**Когда использовать?**

Команда INSERT применяется тогда, когда вам нужно добавить новую запись в базу данных. Это может понадобиться, например, при регистрации нового пользователя, добавлении товара в каталог, создании новой записи о транзакции и так далее.

### Команда UPDATE

Команда UPDATE используется для изменения данных в уже существующих строках таблицы. Вы можете обновить одно или несколько полей у одной или нескольких строк одновременно.

**Синтаксис**

```sql
UPDATE имя_таблицы

SET имя_столбца1 = новое_значение1,

    имя_столбца2 = новое_значение2,

    ...

WHERE условие;
```

**Описание элементов синтаксиса:**

- **имя_таблицы** — таблица, в которой нужно изменить данные.
- **SET имя*столбца1 = новое*значение1** и последующие пары — указывают, какие именно поля и какими значениями обновляются.
- **WHERE условие** (опционально) — определяет, какие строки подлежат изменению. Если условие отсутствует, обновление затронет все строки таблицы.

**Примеры использования оператора UPDATE:**

**Пример 1: Обновляем конкретную строку:**

```sql
UPDATE users

SET email = 'new_email@example.com'

WHERE id = 1;
```

Этот запрос обновит электронную почту пользователя с идентификатором 1.

**Пример 2: Обновляем несколько полей сразу:**

```sql
UPDATE products

SET price = price * 1.05, -- увеличиваем цену на 5%

    updated_at = NOW()

WHERE category_id = 42;
```

Здесь обновляется цена всех продуктов категории с идентификатором 42, а также фиксируется дата обновления.

**Пример 3: Без условия WHERE:**

```sql
UPDATE users

SET is_active = false;
```

Этот запрос деактивирует всех пользователей, установив значение is_active в false.

**Когда использовать?**

Команда UPDATE необходима, когда требуется изменить существующие данные в базе. Например, вы хотите обновить контактную информацию клиента, изменить статус заказа, скорректировать цены товаров и т.п.

### Команда DELETE

Команда DELETE удаляет одну или несколько строк из таблицы. При этом сама структура таблицы остается неизменной.

**Синтаксис**

```sql
DELETE FROM имя_таблицы

WHERE условие;
```

**Описание элементов синтаксиса:**

- **имя_таблицы** — название таблицы, из которой нужно удалить строки.
- **условие** — критерий отбора строк, подлежащих удалению. Если оно отсутствует, удаляются все строки из таблицы.

**Примеры использования оператора DELETE:**

**Пример 1: Удаление конкретной строки:**

```sql
DELETE FROM users

WHERE id = 4;
```

Удаляется пользователь с идентификатором 4.

**Пример 2: Удаление всех неактивных пользователей:**

```sql
DELETE FROM users

WHERE is_active = false;
```

Удаляются все пользователи, у которых значение is_active равно false.

**Пример 3: Удаляем все строки без условий:**

```sql
DELETE FROM orders;
```

Удаляются все заказы из таблицы orders.

**Когда использовать?**

Команда DELETE нужна, чтобы очистить базу от устаревших или ненужных данных. Например, удаление заказов после завершения обработки, удаление неактивных пользователей, очистка временных таблиц и т.д.

### Дополнительные аргументы команд манипулирования данными

Помимо основных параметров, рассмотренных ранее, команды INSERT, UPDATE и DELETE могут включать дополнительные аргументы и опции, расширяющие возможности их применения. Рассмотрим наиболее важные из них.

**Команда INSERT ... RETURNING**

Аргумент RETURNING позволяет вернуть значения столбцов из вновь вставленных строк. Это полезно, когда вам нужно получить идентификатор новой записи или другие данные, которые автоматически генерируются системой (например, значения типа SERIAL).

**Синтаксис:**

```sql
INSERT INTO имя_таблицы [(имя_столбца1, имя_столбца2, ...)]

VALUES (значение1, значение2, ...)

RETURNING имя_столбца1, имя_столбца2, ...;
```

**Пример:**

```sql
INSERT INTO users (name, email)

VALUES ('Алексей', 'alexey@example.com')

RETURNING id, created_at;
```

Здесь будет возвращен идентификатор (id) и время создания (created_at) новой записи.

**Команда INSERT ... ON CONFLICT DO NOTHING / DO UPDATE**

Эта конструкция позволяет обрабатывать конфликты при вставке данных, возникающие, например, при наличии уникального ограничения. Опция ON CONFLICT может принимать два варианта действий:

- DO NOTHING: ничего не делать, если возникает конфликт.
- DO UPDATE: обновить существующие строки вместо вставки новых.

**Синтаксис:**

```sql
INSERT INTO имя_таблицы [(имя_столбца1, имя_столбца2, ...)]

VALUES (значение1, значение2, ...)

ON CONFLICT (имя_конфликтующего_столбца) DO NOTHING;
```

или

```sql
INSERT INTO имя_таблицы [(имя_столбца1, имя_столбца2, ...)]

VALUES (значение1, значение2, ...)

ON CONFLICT (имя_конфликтующего_столбца) DO UPDATE SET имя_обновляемого_столбца = новое_значение;
```

**Пример:**

```sql
INSERT INTO users (id, name, email)

VALUES (1, 'Иван Иванов', 'ivan@example.com')

ON CONFLICT (id) DO NOTHING;
```

Если запись с таким же id уже существует, она останется без изменений.

```sql
INSERT INTO users (id, name, email)

VALUES (1, 'Иван Иванов', 'ivan@example.com')

ON CONFLICT (id) DO UPDATE

   SET name = EXCLUDED.name,

       email = EXCLUDED.email;
```

Если запись с таким же id уже существует, её имя и электронная почта будут обновлены новыми значениями.

**Команда UPDATE ... RETURNING**

Как и в случае с командой INSERT, аргумент RETURNING возвращает значения столбцов из обновлённых строк.

**Синтаксис:**

```sql
UPDATE имя_таблицы

SET имя_столбца1 = новое_значение1,

    имя_столбца2 = новое_значение2,

    ...

WHERE условие

RETURNING имя_столбца1, имя_столбца2, ...;
```

**Пример:**

```sql
UPDATE users

SET email = 'new_email@example.com'

WHERE id = 1

RETURNING id, email;
```

Возвращает идентификатор и новый адрес электронной почты обновленной записи.

**Команда UPDATE ... FROM**

Опция FROM позволяет включить в оператор UPDATE дополнительные таблицы, которые будут использоваться для выбора данных для обновления.

**Синтаксис:**

```sql
UPDATE имя_таблицы

SET имя_столбца1 = выражение1,

    имя_столбца2 = выражение2,

    ...

FROM дополнительная_таблица

WHERE условие;
```

**Пример:**

```sql
UPDATE products

SET price = new_prices.price

FROM (SELECT product_id, price FROM prices WHERE date = '2023-01-01') AS new_prices

WHERE products.product_id = new_prices.product_id;
```

Обновляет цены продуктов на основе данных из временной таблицы new_prices.

**Команда DELETE ... USING**

Конструкция USING позволяет указывать дополнительные таблицы для выполнения условия удаления.

**Синтаксис:**

```sql
DELETE FROM имя_таблицы

USING дополнительная_таблица

WHERE условие;
```

**Пример:**

```sql
DELETE FROM orders

USING customers

WHERE orders.customer_id = customers.id AND customers.is_active = false;
```

Удаляет все заказы, принадлежащие неактивным пользователям.

**Команда DELETE ... RETURNING**

Также как и в командах INSERT и UPDATE, аргумент RETURNING позволяет вернуть значения столбцов удаленных строк.

**Синтаксис:**

```sql
DELETE FROM имя_таблицы

WHERE условие

RETURNING имя_столбца1, имя_столбца2, ...;
```

**Пример:**

```sql
DELETE FROM users

WHERE is_active = false

RETURNING id, name;
```

Возвратит идентификаторы и имена удаленных пользователей.

Эти дополнительные аргументы значительно расширяют функциональность базовых команд манипулирования данными, позволяя более гибко управлять процессами вставки, обновления и удаления данных в базе.

### Заключение

Команды INSERT, UPDATE и DELETE являются основными инструментами для манипуляции данными в PostgreSQL. Они позволяют добавлять, изменять и удалять записи в таблицах базы данных. Правильное понимание и применение этих операторов критически важно для поддержания актуальности и целостности информации в вашей системе.

При использовании этих команд следует помнить об осторожности, особенно при выполнении операций удаления и массового обновления данных. Всегда проверяйте условия фильтрации перед выполнением запросов, чтобы избежать нежелательных последствий.

---

## Урок 2: Использование команды SELECT для выборки из таблицы.

Целью данного учебного пособия является освоение студентами основ работы с командой SELECT в SQL для выборки данных из таблиц базы данных PostgreSQL. После успешного прохождения курса студенты смогут:

- Понимать структуру и синтаксис команды SELECT.
- Формировать запросы для извлечения необходимых данных из одной или нескольких таблиц.
- Применять различные фильтры и условия для сужения результатов выборки.
- Использовать агрегатные функции для анализа данных.
- Группировать результаты выборки и агрегировать данные.
- Осваивать работу с подзапросами и различными элементами SQL-запросов для решения сложных задач.

### Введение

Команда SELECT является основой языка структурированных запросов (SQL). Она служит главным инструментом для извлечения данных из базы данных. Эта команда позволяет выбрать необходимые столбцы и строки из одной или нескольких связанных таблиц, применив к ним различные условия и преобразования. Эффективное использование команды SELECT требует понимания ее возможностей и правильного применения различных операторов и функций.

В рамках данного пособия мы подробно разберем все аспекты работы с командой SELECT, начиная с простого вывода отдельных столбцов и заканчивая сложными запросами с использованием группировки, агрегаций и подзапросов.

### Синтаксис оператора SELECT

Основной синтаксис команды выглядит следующим образом:

```sql
SELECT [DISTINCT | ALL] {имена_столбцов | выражения}

FROM имя_таблицы

[WHERE условие]

[GROUP BY имя_группы]

[HAVING условие_агрегата]

[ORDER BY порядок_сортировки];
```

Разберёмся с каждым элементом синтаксиса по отдельности.

**Основные компоненты команды SELECT**

1. **SELECT**: Ключевое слово, которое указывает, что данный запрос предназначен для выборки данных.
2. **`{имена_столбцов | выражения}`**: Список имен столбцов или выражений, которые необходимо вывести в результате запроса. Можно использовать символ \* для вывода всех столбцов.
3. **FROM имя_таблицы**: Указывает таблицу, из которой выбираются данные.
4. **WHERE условие**: Фильтрует строки, удовлетворяющие заданному условию.
5. **GROUP BY имя_группы**: Используется для группировки строк по одному или нескольким столбцам.
6. **HAVING условие_агрегата**: Применяется для фильтрации группированных данных.
7. **ORDER BY порядок_сортировки**: Сортирует результат выборки по указанному порядку.
8. **LIMIT и OFFSET**: Ограничивают количество выводимых строк и задают смещение начала выборки.

Рассмотрим каждый элемент более подробно.

### Выбор столбцов

Команда SELECT позволяет выбирать конкретные столбцы из таблицы. Например:

```sql
SELECT имя_столбца1, имя_столбца2

FROM имя_таблицы;
```

Здесь выбираются два столбца из указанной таблицы.

Можно использовать символ \* для выбора всех столбцов:

```sql
SELECT *

FROM имя_таблицы;

__DISTINCT и ALL__
```

По умолчанию команда SELECT выводит все строки, включая дубликаты. Чтобы исключить повторяющиеся строки, используется ключевое слово DISTINCT:

```sql
SELECT DISTINCT имя_столбца

FROM имя_таблицы;
```

Это выведет уникальные значения указанного столбца.

Ключевое слово ALL используется редко, но оно присутствует для явного указания того, что нужно вывести все строки, включая дубликаты.

### Фильтрация строк с помощью WHERE

Условие WHERE позволяет ограничить набор строк, которые будут выбраны из таблицы. Оно работает аналогично условиям в математике:

```sql
SELECT имя_столбца1, имя_столбца2

FROM имя_таблицы

WHERE условие;
```

Примеры условий:

- = (равенство),
- &lt;, &lt;=, >, >= (меньше, меньше или равно, больше, больше или равно),
- &lt;> или != (не равно),
- BETWEEN a AND b,
- IN (список_значений),
- LIKE 'шаблон' (для поиска по шаблонам),
- IS NULL и IS NOT NULL.

Например:

```sql
SELECT *

FROM users

WHERE age > 18;
```

### Группировка данных с помощью GROUP BY

Оператор GROUP BY используется для объединения строк с одинаковыми значениями одного или нескольких столбцов. Обычно он применяется вместе с агрегатными функциями, такими как COUNT(), SUM(), AVG() и другими.

```sql
SELECT имя_столбца1, агрегатная_функция(имя_столбца2)

FROM имя_таблицы

GROUP BY имя_столбца1;
```

Пример:

```sql
SELECT department, COUNT(employee_id)

FROM employees

GROUP BY department;
```

### Агрегатные функции

Агрегатные функции применяются для вычисления итоговых значений по группе строк. Вот некоторые из них:

- COUNT(\*): Подсчитывает количество строк.
- SUM(имя_столбца): Суммирует значения в указанном столбце.
- AVG(имя_столбца): Вычисляет среднее арифметическое значение.
- MIN(имя_столбца): Находит минимальное значение.
- MAX(имя_столбца): Находит максимальное значение.

Пример:

```sql
SELECT AVG(salary)

FROM employees;
```

### HAVING

Оператор HAVING используется для фильтрации группированных данных. Он похож на WHERE, но применяется после группировки.

```sql
SELECT имя_столбца1, агрегатная_функция(имя_столбца2)

FROM имя_таблицы

GROUP BY имя_столбца1

HAVING условие_агрегата;
```

Пример:

```sql
SELECT department, SUM(salary)

FROM employees

GROUP BY department

HAVING SUM(salary) > 1000000;
```

### Сортировка результата с ORDER BY

Оператор ORDER BY сортирует результат выборки по указанным столбцам. Можно сортировать по возрастанию (ASC) или убыванию (DESC):

```sql
SELECT *

FROM имя_таблицы

ORDER BY имя_столбца ASC|DESC;
```

Пример:

```sql
SELECT employee_id, salary

FROM employees

ORDER BY salary DESC;

__LIMIT и OFFSET__
```

Ограничивает количество строк, возвращаемых в результате запроса, и задает смещение начала выборки (т.е. указывает, сколько строк в таблице необходимо пропустить):

```sql
SELECT *

FROM имя_таблицы

LIMIT число_строк [OFFSET смещение];

Пример:

SELECT *

FROM employees

LIMIT 10 OFFSET 50;
```

### Подзапросы

Подзапросы – это запросы внутри других запросов. Они могут использоваться в разных частях основного запроса: в списке столбцов, в условиях WHERE, HAVING, а также в качестве источника данных в конструкции FROM.

Пример подзапроса в списке столбцов:

```sql
SELECT employee_id, (SELECT department_name FROM departments WHERE department_id = e.department_id) as department

FROM employees e;
```

Пример подзапроса в условии WHERE:

```sql
SELECT employee_id, salary

FROM employees

WHERE salary > (SELECT AVG(salary) FROM employees);
```

### Заключение

Команда SELECT является основным инструментом для извлечения данных из базы данных. Ее правильная настройка и использование позволяют эффективно решать задачи анализа и обработки данных. Мы рассмотрели основные элементы синтаксиса, способы фильтрации, группировки и агрегации данных, а также подзапросы.

После освоения материала данного пособия студенты смогут уверенно работать с запросами выборки данных в PostgreSQL, создавая сложные и эффективные SQL-запросы для решения разнообразных задач.

---

## Практика: Манипулирование данными в базе данных PostgreSQL

1. **Запуск PostgreSQL и подключение к базе данных**

Для начала работы с PostgreSQL подключитесь к базе данных по умолчанию (например, postgres) через утилиту командной строки psql или интерфейс, запустите редактор SQL-запросов.

2. **Создание базы данных**

Создайте новую базу данных с именем ShopDB с параметрами по умолчанию.

3. **Создание таблицы Authors**

Создайте таблицу Goods (товары) в БД ShopDB со следующими свойствами:

<table>
  <tr>
   <td>Атрибут</td>
   <td>Описание*</td>
   <td>Тип</td>
   <td>Уникальность</td>
   <td>По умолчанию</td>
   <td>Пустые значения</td>
   <td>Условие</td>
  </tr>
  <tr>
   <td>DeptID</td>
   <td>Номер отдела</td>
   <td>int</td>
   <td></td>
   <td>1</td>
   <td>NOT NULL</td>
   <td>>=1 и &lt;=10</td>
  </tr>
  <tr>
   <td>GoodID</td>
   <td>Номер товара</td>
   <td>int</td>
   <td>PK</td>
   <td></td>
   <td>NOT NULL</td>
   <td></td>
  </tr>
  <tr>
   <td>GName</td>
   <td>Наименование товара</td>
   <td>varchar(20)</td>
   <td rowspan="2" >Unique**</td>
   <td></td>
   <td>NOT NULL</td>
   <td></td>
  </tr>
  <tr>
   <td>Descr</td>
   <td>Описание товара</td>
   <td>varchar(20)</td>
   <td></td>
   <td>NULL</td>
   <td></td>
  </tr>
  <tr>
   <td>Price</td>
   <td>Цена</td>
   <td>DECIMAL(10, 4)</td>
   <td></td>
   <td></td>
   <td>NOT NULL</td>
   <td>>0</td>
  </tr>
  <tr>
   <td>GCount</td>
   <td>Количество</td>
   <td>int</td>
   <td></td>
   <td></td>
   <td>NOT NULL</td>
   <td>>0</td>
  </tr>
</table>

`*` Столбец Описание приведен для информации об атрибутах и никак не участвует при создании таблицы.

`**` Уникальной является пара значений атрибутов, а не отдельные атрибуты.

**Команда для создания таблицы:**

```sql
    CREATE TABLE Goods (
        DeptID INT NOT NULL DEFAULT 1 CHECK (DeptID >= 1 AND DeptID &lt;= 10),
        GoodID SERIAL PRIMARY KEY,
        GName VARCHAR(20) NOT NULL,
        Descr VARCHAR(50) NULL,
        Price DECIMAL(10, 4) NOT NULL CHECK (Price > 0), -- в postgre нет smallmoney, поэтому просто укажем decimal с точностью до 4х знаков
        GCount INT NOT NULL CHECK (GCount > 0),
        CONSTRAINT Unique_GoodID_GName UNIQUE (GoodID, GName)
    );
```

4. **Заполнение таблицы Goods:**

Заполните таблицу Goods (товары) в БД ShopDB следующими строками, пользуясь графическим интерфейсом или командой INSERT:

<table>
  <tr>
   <td>DeptID</td>
   <td>GoodID</td>
   <td>GName</td>
   <td>Descr</td>
   <td>Price</td>
   <td>GCount</td>
  </tr>
  <tr>
   <td>1</td>
   <td></td>
   <td>Ручка</td>
   <td>шариковая</td>
   <td>2</td>
   <td>100</td>
  </tr>
  <tr>
   <td>1</td>
   <td></td>
   <td>ручка</td>
   <td>гелевая</td>
   <td>10</td>
   <td>50</td>
  </tr>
  <tr>
   <td>1</td>
   <td></td>
   <td>карандаш</td>
   <td>простой</td>
   <td>5</td>
   <td>200</td>
  </tr>
  <tr>
   <td>1</td>
   <td></td>
   <td>карандаш</td>
   <td>механический</td>
   <td>10</td>
   <td>30</td>
  </tr>
  <tr>
   <td>2</td>
   <td> </td>
   <td>мыло </td>
   <td>хозяйственное </td>
   <td>6</td>
   <td>200</td>
  </tr>
  <tr>
   <td>2 </td>
   <td> </td>
   <td>мыло </td>
   <td>детское</td>
   <td>7</td>
   <td>150 </td>
  </tr>
  <tr>
   <td>2 </td>
   <td></td>
   <td>шампунь</td>
   <td>«Чистая линия»</td>
   <td>50</td>
   <td>7</td>
  </tr>
</table>

Почему не нужно заполнять значения атрибута GoodID?

```sql
INSERT INTO Goods (DeptID, GName, Descr, Price, GCount)
VALUES
    (1, 'Ручка', 'шариковая', 2, 100),
    (1, 'Ручка', 'гелевая', 10, 50),
    (1, 'Карандаш', 'простой', 5, 200),
    (1, 'Карандаш', 'механический', 10, 30),
    (2, 'Мыло', 'хозяйственное', 6, 200),
    (2, 'Мыло', 'детское', 7, 150),
    (2, 'Шампунь', '"Чистая линия"', 50, 7);
```

5. **При помощи команды INSERT добавить в таблицу Goods следующие товары:**

<table>
  <tr>
   <td>DeptID</td>
   <td>GoodID</td>
   <td>GName</td>
   <td>Descr</td>
   <td>Price</td>
   <td>GCount</td>
  </tr>
  <tr>
   <td>3</td>
   <td></td>
   <td>хлеб</td>
   <td>сельский</td>
   <td>20</td>
   <td>30</td>
  </tr>
  <tr>
   <td>DEFAULT</td>
   <td></td>
   <td>ручка</td>
   <td>NULL</td>
   <td>15</td>
   <td>40</td>
  </tr>
</table>

```sql
    INSERT INTO Goods (DeptID, GName, Descr, Price, GCount)
    VALUES
        (3, 'хлеб', 'сельский', 20, 30),
        (DEFAULT, 'Ручка', NULL, 15, 40);
```

6. **Пользуясь командой DELETE, удалите из таблицы Goods те товары, у которых не задано описание (т.е. Descr принимает значение null).**

```sql
    DELETE FROM Goods
    WHERE Descr IS NULL;
```

7. **Пользуясь командой UPDATE, обновите таблицу Goods – увеличьте цены на все товары на 10%.**

```sql
    UPDATE Goods
    SET Price = Price * 1.1;
```

8. **Пользуясь командой SELECT, выведите таблицу Goods.**

```sql
    SELECT * FROM Goods;
```

9. **Выведите все товары (их номер, имя и описание), которые продаются в первом отделе.**

```sql
    SELECT GoodID, GName, Descr
    FROM Goods
    WHERE DeptID = 1;
```

10. **Выведите все сведения о товарах в ценовом диапазоне от 10 до 30 рублей, используя предикат BETWEEN**

```sql
    SELECT GoodID, GName, Price
    FROM Goods
    WHERE Price BETWEEN 10 AND 30;
```

11. **Выведите все сведения о товарах первого и третьего отдела, используя предикат IN.**

```sql
    SELECT GoodID, GName, DeptID
    FROM Goods
    WHERE DeptID IN (1, 3);
```

12. **Выведите все сведения о товарах, имя которых начинается на ‘р’, используя предикат LIKE.**

```sql
    SELECT GoodID, GName, Price
    FROM Goods
    WHERE lower(GName) LIKE 'р%';
```

13. **Выведите все сведения о товарах, в имени которых встречается символ ‘\_’, используя предикат LIKE.**

```sql
    SELECT GoodID, GName, Price
    FROM Goods
    WHERE GName LIKE 'А';
```

14. **Выведите наименования всех товаров.**

```sql
    SELECT GName
    FROM Goods;
```

15. **Выведите наименования всех товаров без повторений.**

```sql
    SELECT DISTINCT GName
    FROM Goods;
```

16. **Выведите все сведения о товарах плюс вычисляемый столбец – стоимость каждого товара (цена \* количество).**

```sql
    SELECT GoodID, GName, Price, GCount, Price * GCount AS Cost
    FROM Goods;
```

17. **Выведите минимальную, среднюю, максимальную цену по всем товарам.**

```sql
    SELECT MIN(Price) AS MinPrice, AVG(Price) AS AvgPrice, MAX(Price) AS MaxPrice
    FROM Goods;
```

18. **Выведите количество наименований товаров, продающихся в первом отделе.**

```sql
    SELECT COUNT(DISTINCT GName) AS NumGoods
    FROM Goods
    WHERE DeptID = 1;
```

19. **Выведите количество товаров, для которых задано описание (Descr не null).**

```sql
    SELECT COUNT(*)
    FROM Goods
    WHERE Descr IS NOT NULL;
```

20. **Выведите суммарную стоимость товаров по второму отделу.**

```sql
    SELECT SUM(Price * GCount) AS TotalCost
    FROM Goods
    WHERE DeptID = 2;
```

21. **Выведите все товары, упорядочивая по именам.**

```sql
    SELECT * FROM Goods
    ORDER BY GName;
```

22. **Выведите все товары, упорядочивая по отделам и по убыванию цены.**

```sql
    SELECT * FROM Goods
    ORDER BY DeptID, Price DESC;
```

23. **Вычислите стоимость проданного товара по каждому отделу.**

```sql
    SELECT DeptID, SUM(Price * GCount) AS TotalCost
    FROM Goods
    GROUP BY DeptID;
```

24. **Вычислите среднюю цену только по тем товарам, цена которых превышает 9 рублей.**

```sql
    SELECT AVG(Price) AS AvgPrice
    FROM Goods
    WHERE Price > 9;
```

25. **Вычислите максимальную цену по каждому наименованию товара.**

```sql
    SELECT GName, MAX(Price) AS MaxPrice
    FROM Goods
    GROUP BY GName;
```

26. **Выведите номера отделов, где продается более одного наименования товаров.**

```sql
    SELECT DeptID
    FROM Goods
    GROUP BY DeptID
    HAVING COUNT(DISTINCT GName) > 1;
```

27. **Завершение работы**. **После выполнения всех шагов сохраните скрипт лабораторной работы для отчёта.**
